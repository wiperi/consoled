#!/usr/bin/env python3
"""
Console Monitor Service

Unified Console Monitor service with three modes:
- ptyhub: PTY Hub service that creates PTY pairs and bridges them
- dce: DCE service that manages SerialProxy instances
- dte: DTE service that sends heartbeat frames

Usage:
    console-monitor ptyhub           # Start PTY Hub service
    console-monitor dce              # Start DCE service
    console-monitor dte [tty] [baud] # Start DTE service
"""

import os
import re
import sys
import time
import fcntl
import termios
import tty
import signal
import argparse
import logging
import threading
import select
from dataclasses import dataclass
from enum import IntEnum
from typing import Optional, Callable, Dict, Set

from swsscommon.swsscommon import (
    DBConnector,
    Table,
    ConfigDBConnector,
)

# ============================================================
# Logging Configuration
# ============================================================

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
log = logging.getLogger("console-monitor")


# ============================================================
# Global Constants
# ============================================================

# Timeout configuration
HEARTBEAT_INTERVAL = 5.0      # DTE heartbeat send interval (seconds)
HEARTBEAT_TIMEOUT = 15.0      # DCE heartbeat timeout (seconds)
RETRY_INTERVAL = 3.0          # Retry interval for waiting phases (seconds)

# Baud rate mapping
BAUD_MAP = {
    1200: termios.B1200,
    2400: termios.B2400,
    4800: termios.B4800,
    9600: termios.B9600,
    19200: termios.B19200,
    38400: termios.B38400,
    57600: termios.B57600,
    115200: termios.B115200,
}

# Redis table names
CONSOLE_PORT_TABLE = "CONSOLE_PORT"
CONSOLE_SWITCH_TABLE = "CONSOLE_SWITCH"

# Default baud rate
DEFAULT_BAUD = 9600

# Kernel command line path
PROC_CMDLINE = "/proc/cmdline"

# PTY symlink suffixes
PTY_SYMLINK_SUFFIX_PTS = "-PTS"  # For user applications (picocom)
PTY_SYMLINK_SUFFIX_PTM = "-PTM"  # For SerialProxy

# Exit codes
EXIT_SUCCESS = 0
EXIT_SERVICE_START_FAILED = 1
EXIT_SERIAL_CONFIG_ERROR = 2
EXIT_INVALID_MODE = 3


# ============================================================
# Frame Protocol Constants and Classes
# ============================================================

class SpecialChar(IntEnum):
    """Special character definitions"""
    SOF = 0x05  # Start of Frame
    EOF = 0x00  # End of Frame
    DLE = 0x10  # Data Link Escape


# Set of escapable characters
ESCAPABLE_CHARS = frozenset({SpecialChar.SOF, SpecialChar.EOF, SpecialChar.DLE})


class FrameType(IntEnum):
    """Frame type definitions"""
    HEARTBEAT = 0x01


# Protocol version
PROTOCOL_VERSION = 0x01

# SOF/EOF length
SOF_LEN = 3
EOF_LEN = 3

# Buffer size limit
MAX_FRAME_BUFFER_SIZE = 64

# SOF/EOF sequences
SOF_SEQUENCE = bytes([SpecialChar.SOF] * SOF_LEN)
EOF_SEQUENCE = bytes([SpecialChar.EOF] * EOF_LEN)


def log_binary_data(data: bytes, direction: str) -> None:
    """
    Output data in binary and readable form to terminal

    Args:
        data: Byte data to output
        direction: Data flow direction (e.g., "Serial→PTY", "PTY→Serial")
    """
    hex_str = data.hex(' ', 1)
    readable = ''.join(chr(b) if 32 <= b < 127 else f"<0x{b:02x}>" for b in data)
    log.debug(f"[{direction}] ({len(data)} bytes):\n  HEX: {hex_str}\n  ASCII: {readable}\n")


def crc16_modbus(data: bytes) -> int:
    """CRC-16/MODBUS algorithm"""
    crc = 0xFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x0001:
                crc = (crc >> 1) ^ 0xA001
            else:
                crc >>= 1
    return crc


def escape_data(data: bytes) -> bytes:
    """Escape data"""
    result = bytearray()
    for byte in data:
        if byte in ESCAPABLE_CHARS:
            result.append(SpecialChar.DLE)
        result.append(byte)
    return bytes(result)


def unescape_data(data: bytes) -> bytes:
    """Unescape data"""
    result = bytearray()
    i = 0
    while i < len(data):
        if data[i] == SpecialChar.DLE and i + 1 < len(data) and data[i + 1] in ESCAPABLE_CHARS:
            result.append(data[i + 1])
            i += 2
        else:
            result.append(data[i])
            i += 1
    return bytes(result)


@dataclass
class Frame:
    """Frame data structure"""
    version: int = PROTOCOL_VERSION
    seq: int = 0
    flag: int = 0x00
    frame_type: int = FrameType.HEARTBEAT
    payload: bytes = b""

    def build(self) -> bytes:
        """Build complete frame binary sequence"""
        content = bytes([
            self.version,
            self.seq & 0xFF,
            self.flag,
            self.frame_type,
            len(self.payload),
        ]) + self.payload

        crc = crc16_modbus(content)
        crc_bytes = bytes([crc >> 8, crc & 0xFF])

        content_with_crc = content + crc_bytes
        escaped_content = escape_data(content_with_crc)

        return SOF_SEQUENCE + escaped_content + EOF_SEQUENCE

    @classmethod
    def parse(cls, buffer: bytes) -> Optional['Frame']:
        """Parse frame from buffer"""
        unescaped = unescape_data(buffer)

        if len(unescaped) < 7:
            return None

        content = unescaped[:-2]
        crc_bytes = unescaped[-2:]

        expected_crc = crc16_modbus(content)
        received_crc = (crc_bytes[0] << 8) | crc_bytes[1]

        if expected_crc != received_crc:
            return None

        if len(content) < 5:
            return None

        version = content[0]
        seq = content[1]
        flag = content[2]
        frame_type = content[3]
        length = content[4]
        payload = content[5:5 + length] if length > 0 else b""

        return cls(
            version=version,
            seq=seq,
            flag=flag,
            frame_type=frame_type,
            payload=payload,
        )

    @classmethod
    def create_heartbeat(cls, seq: int = 0) -> 'Frame':
        """Create heartbeat frame"""
        return cls(
            version=PROTOCOL_VERSION,
            seq=seq,
            flag=0x00,
            frame_type=FrameType.HEARTBEAT,
            payload=b"",
        )

    def is_heartbeat(self) -> bool:
        """Check if this is a heartbeat frame"""
        return self.frame_type == FrameType.HEARTBEAT


# Callback function types
FrameCallback = Callable[[Frame], None]
UserDataCallback = Callable[[bytes], None]


class FrameFilter:
    """Frame filter: identifies frames and user data from byte stream"""

    def __init__(
        self,
        on_frame: Optional[FrameCallback] = None,
        on_user_data: Optional[UserDataCallback] = None,
    ):
        self._on_frame = on_frame
        self._on_user_data = on_user_data
        self._buffer = bytearray()
        self._escape_next = False
        self._in_frame = False

    def process(self, data: bytes) -> None:
        """Process input byte stream"""
        log_binary_data(data, "Received")

        for byte in data:
            if self._escape_next:
                self._buffer.append(byte)
                self._escape_next = False
                if len(self._buffer) >= MAX_FRAME_BUFFER_SIZE:
                    self._flush_buffer()

            elif byte == SpecialChar.DLE:
                self._buffer.append(byte)
                if self.in_frame:
                    self._escape_next = True

            elif byte == SpecialChar.SOF:
                if not self._in_frame:
                    self._flush_as_user_data()
                else:
                    self._discard_buffer()
                self._in_frame = True

            elif byte == SpecialChar.EOF:
                self._try_parse_frame()
                self._in_frame = False

            else:
                self._buffer.append(byte)
                if len(self._buffer) >= MAX_FRAME_BUFFER_SIZE:
                    self._flush_buffer()

    def on_timeout(self) -> None:
        """Timeout callback"""
        if not self._in_frame:
            self._flush_as_user_data()
        else:
            self._discard_buffer()
        self._in_frame = False

    def flush(self) -> bytes:
        """Flush buffer and return remaining data"""
        result = bytes(self._buffer)
        self._buffer.clear()
        self._escape_next = False
        self._in_frame = False
        return result

    def has_pending_data(self) -> bool:
        """Check if there is pending data"""
        return len(self._buffer) > 0

    @property
    def in_frame(self) -> bool:
        """Check if currently inside a frame"""
        return self._in_frame

    def _flush_as_user_data(self) -> None:
        """Send buffer as user data"""
        if self._buffer and self._on_user_data:
            log_binary_data(self._buffer, 'User Data')
            self._on_user_data(bytes(self._buffer))
        self._buffer.clear()
        self._escape_next = False

    def _discard_buffer(self) -> None:
        """Discard buffer"""
        self._buffer.clear()
        self._escape_next = False

    def _flush_buffer(self) -> None:
        """Handle buffer overflow based on whether inside a frame"""
        if not self._in_frame:
            self._flush_as_user_data()
        else:
            self._discard_buffer()
        self._in_frame = False

    def _try_parse_frame(self) -> None:
        """Try to parse buffer as frame"""
        if not self._buffer:
            self._escape_next = False
            return

        log_binary_data(self._buffer, 'Frame Data')

        frame = Frame.parse(bytes(self._buffer))
        self._buffer.clear()
        self._escape_next = False

        if frame is not None and self._on_frame:
            self._on_frame(frame)


# ============================================================
# Utility Functions
# ============================================================

def get_udev_prefix() -> Optional[str]:
    """
    Read udev prefix from udevprefix.conf

    Returns:
        Prefix string (e.g., "C0-") or None if not available
    """
    try:
        from sonic_py_common import device_info
        platform_path, _ = device_info.get_paths_to_platform_and_hwsku_dirs()
        config_file = os.path.join(platform_path, "udevprefix.conf")

        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                prefix = f.readline().rstrip()
                if prefix:
                    return prefix
    except Exception as e:
        log.warning(f"Failed to read udevprefix.conf: {e}")

    return None


def wait_for_udev_prefix(running_flag: Callable[[], bool]) -> Optional[str]:
    """
    Wait for udev prefix to be available (infinite wait)

    Args:
        running_flag: Callable that returns False to stop waiting

    Returns:
        Prefix string or None if stopped
    """
    log.info("Waiting for udev prefix...")

    while running_flag():
        prefix = get_udev_prefix()
        if prefix:
            log.info(f"Udev prefix loaded: {prefix}")
            return prefix

        log.debug(f"Udev prefix not found, retrying in {RETRY_INTERVAL}s...")
        time.sleep(RETRY_INTERVAL)

    return None


def set_nonblocking(fd: int) -> None:
    """Set file descriptor to non-blocking mode"""
    flags = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)


def configure_serial(fd: int, baud: int) -> None:
    """Configure serial port parameters"""
    attrs = termios.tcgetattr(fd)
    attrs[0] &= ~(termios.IGNBRK | termios.BRKINT | termios.PARMRK |
                  termios.ISTRIP | termios.INLCR | termios.IGNCR |
                  termios.ICRNL | termios.IXON)
    attrs[1] &= ~termios.OPOST
    attrs[2] &= ~(termios.CSIZE | termios.PARENB)
    attrs[2] |= (termios.CS8 | termios.CREAD | termios.CLOCAL)
    attrs[3] &= ~(termios.ECHO | termios.ECHONL | termios.ICANON |
                  termios.ISIG | termios.IEXTEN)
    attrs[6][termios.VMIN] = 0
    attrs[6][termios.VTIME] = 0
    speed = BAUD_MAP.get(baud, termios.B9600)
    attrs[4] = attrs[5] = speed
    termios.tcsetattr(fd, termios.TCSANOW, attrs)
    termios.tcflush(fd, termios.TCIOFLUSH)


def configure_pty(fd: int) -> None:
    """Configure PTY in raw mode"""
    tty.setraw(fd, when=termios.TCSANOW)
    attrs = termios.tcgetattr(fd)
    attrs[3] &= ~(termios.ECHO | termios.ECHONL)
    termios.tcsetattr(fd, termios.TCSANOW, attrs)


def parse_proc_cmdline() -> tuple[str, int]:
    """
    Parse serial configuration from /proc/cmdline

    Returns:
        (tty_name, baud)

    Raises:
        ValueError: No valid console parameter found
    """
    try:
        with open(PROC_CMDLINE, 'r') as f:
            cmdline = f.read().strip()
    except Exception as e:
        raise ValueError(f"Failed to read {PROC_CMDLINE}: {e}")

    pattern = r'console=([a-zA-Z0-9]+)(?:,([0-9]+))?'
    matches = re.findall(pattern, cmdline)

    if not matches:
        raise ValueError(f"No console= parameter found in {PROC_CMDLINE}")

    tty_name, baud_str = matches[-1]
    baud = int(baud_str) if baud_str else DEFAULT_BAUD

    log.info(f"Parsed from /proc/cmdline: tty={tty_name}, baud={baud}")
    return (tty_name, baud)


def calculate_filter_timeout(baud: int, multiplier: int = 3) -> float:
    """Calculate frame filter timeout based on baud rate"""
    char_time = 10.0 / baud
    return char_time * MAX_FRAME_BUFFER_SIZE * multiplier


# ============================================================
# PTY Bridge (Single Link)
# ============================================================

class PTYBridge:
    """
    PTY Bridge for a single console link

    Creates two PTY pairs and bridges their masters:
    - PTS: /dev/{prefix}{link_id}-PTS  (for user applications like picocom)
    - PTM: /dev/{prefix}{link_id}-PTM  (for SerialProxy)

    Data flow:
    picocom <-> PTS_slave <-> PTS_master <--bridge--> PTM_master <-> PTM_slave <-> SerialProxy
    """

    def __init__(self, link_id: str, udev_prefix: str):
        self.link_id = link_id
        self.udev_prefix = udev_prefix

        # PTY pair 1 (for user applications)
        self.pts_master: int = -1
        self.pts_slave: int = -1
        self.pts_symlink: str = ""

        # PTY pair 2 (for SerialProxy)
        self.ptm_master: int = -1
        self.ptm_slave: int = -1
        self.ptm_symlink: str = ""

        # Bridge thread
        self.running: bool = False
        self._thread: Optional[threading.Thread] = None
        self._wake_r: int = -1
        self._wake_w: int = -1

    def start(self) -> bool:
        """
        Start PTY bridge

        Returns:
            True if successful, False otherwise
        """
        try:
            # Create wake-up pipe
            self._wake_r, self._wake_w = os.pipe()
            set_nonblocking(self._wake_r)

            # Create PTY pair 1 (PTS - for user applications)
            self.pts_master, self.pts_slave = os.openpty()
            pts_slave_name = os.ttyname(self.pts_slave)
            os.chmod(pts_slave_name, 0o666)
            configure_pty(self.pts_master)
            set_nonblocking(self.pts_master)

            # Create PTY pair 2 (PTM - for SerialProxy)
            self.ptm_master, self.ptm_slave = os.openpty()
            ptm_slave_name = os.ttyname(self.ptm_slave)
            os.chmod(ptm_slave_name, 0o666)
            configure_pty(self.ptm_master)
            set_nonblocking(self.ptm_master)

            # Create symlinks
            self.pts_symlink = f"/dev/{self.udev_prefix}{self.link_id}{PTY_SYMLINK_SUFFIX_PTS}"
            self.ptm_symlink = f"/dev/{self.udev_prefix}{self.link_id}{PTY_SYMLINK_SUFFIX_PTM}"

            self._create_symlink(self.pts_symlink, pts_slave_name)
            self._create_symlink(self.ptm_symlink, ptm_slave_name)

            # Start bridge thread
            self.running = True
            self._thread = threading.Thread(target=self._bridge_loop, daemon=True)
            self._thread.start()

            log.info(f"[PTYBridge:{self.link_id}] Started: {self.pts_symlink} <-> {self.ptm_symlink}")
            return True

        except Exception as e:
            log.error(f"[PTYBridge:{self.link_id}] Failed to start: {e}")
            self.stop()
            return False

    def stop(self) -> None:
        """Stop PTY bridge and cleanup resources"""
        self.running = False

        # Wake up bridge thread
        if self._wake_w >= 0:
            try:
                os.write(self._wake_w, b'x')
            except Exception:
                pass

        # Wait for thread
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=2.0)

        # Remove symlinks
        self._remove_symlink(self.pts_symlink)
        self._remove_symlink(self.ptm_symlink)
        self.pts_symlink = ""
        self.ptm_symlink = ""

        # Close file descriptors
        for fd in (self._wake_r, self._wake_w, self.pts_master, self.pts_slave,
                   self.ptm_master, self.ptm_slave):
            if fd >= 0:
                try:
                    os.close(fd)
                except OSError:
                    pass

        self._wake_r = self._wake_w = -1
        self.pts_master = self.pts_slave = -1
        self.ptm_master = self.ptm_slave = -1

        log.info(f"[PTYBridge:{self.link_id}] Stopped")

    def _bridge_loop(self) -> None:
        """Bridge loop: forward data between two PTY masters"""
        while self.running:
            try:
                readable, _, _ = select.select(
                    [self.pts_master, self.ptm_master, self._wake_r],
                    [], [],
                    1.0
                )

                if not self.running:
                    break

                for fd in readable:
                    if fd == self.pts_master:
                        # PTS -> PTM
                        try:
                            data = os.read(self.pts_master, 4096)
                            if data:
                                os.write(self.ptm_master, data)
                        except (BlockingIOError, OSError):
                            pass
                    elif fd == self.ptm_master:
                        # PTM -> PTS
                        try:
                            data = os.read(self.ptm_master, 4096)
                            if data:
                                os.write(self.pts_master, data)
                        except (BlockingIOError, OSError):
                            pass
                    elif fd == self._wake_r:
                        # Wake-up signal
                        try:
                            os.read(self._wake_r, 1024)
                        except OSError:
                            pass

            except Exception as e:
                if self.running:
                    log.error(f"[PTYBridge:{self.link_id}] Bridge error: {e}")
                    time.sleep(0.1)

    def _create_symlink(self, symlink_path: str, target: str) -> None:
        """Create symlink"""
        try:
            if os.path.islink(symlink_path) or os.path.exists(symlink_path):
                os.unlink(symlink_path)
            os.symlink(target, symlink_path)
            log.debug(f"[PTYBridge:{self.link_id}] Symlink: {symlink_path} -> {target}")
        except Exception as e:
            log.error(f"[PTYBridge:{self.link_id}] Failed to create symlink {symlink_path}: {e}")
            raise

    def _remove_symlink(self, symlink_path: str) -> None:
        """Remove symlink"""
        if symlink_path:
            try:
                if os.path.islink(symlink_path):
                    os.unlink(symlink_path)
                    log.debug(f"[PTYBridge:{self.link_id}] Symlink removed: {symlink_path}")
            except Exception as e:
                log.error(f"[PTYBridge:{self.link_id}] Failed to remove symlink {symlink_path}: {e}")


# ============================================================
# PTY Hub Service
# ============================================================

class PTYHub:
    """
    PTY Hub Service: manages multiple PTY bridges

    Listens to CONFIG_DB and dynamically creates/removes PTY bridges
    for each console link.
    """

    def __init__(self):
        self.config_db: Optional[ConfigDBConnector] = None
        self.udev_prefix: str = ""
        self.bridges: Dict[str, PTYBridge] = {}
        self.running: bool = False

    def start(self) -> bool:
        """Start PTY Hub service"""
        self.running = True

        # Phase 1: Wait for udev prefix (infinite wait)
        prefix = wait_for_udev_prefix(lambda: self.running)
        if not prefix:
            return False
        self.udev_prefix = prefix

        # Phase 2: Connect to CONFIG_DB
        try:
            self.config_db = ConfigDBConnector()
            self.config_db.connect(wait_for_init=True, retry_on=True)
            log.info("PTYHub: ConfigDB connected")
        except Exception as e:
            log.error(f"PTYHub: Failed to connect to ConfigDB: {e}")
            return False

        return True

    def register_callbacks(self) -> None:
        """Register CONFIG_DB change callbacks"""

        def make_callback(func):
            def callback(table, key, data):
                if data is None:
                    op = "DEL"
                    data = {}
                else:
                    op = "SET"
                return func(key, op, data)
            return callback

        self.config_db.subscribe(CONSOLE_PORT_TABLE,
                                 make_callback(self.console_port_handler))

        log.info("PTYHub: Callbacks registered")

    def run(self) -> None:
        """Main loop: listen for CONFIG_DB changes"""
        try:
            self.config_db.listen(init_data_handler=self._load_initial_config)
        except KeyboardInterrupt:
            log.info("PTYHub: Received keyboard interrupt")
        except Exception as e:
            if self.running:
                log.error(f"PTYHub: Listen error: {e}")

    def stop(self) -> None:
        """Stop PTY Hub service"""
        self.running = False

        # Stop all bridges
        for bridge in self.bridges.values():
            bridge.stop()
        self.bridges.clear()

        log.info("PTYHub: Stopped")

    def _load_initial_config(self, init_data: dict) -> None:
        """Load initial configuration"""
        log.info(f"PTYHub: Loading initial config: {list(init_data.keys())}")
        self._sync()

    def console_port_handler(self, key: str, op: str, data: dict) -> None:
        """CONSOLE_PORT table change handler"""
        log.info(f"PTYHub: CONSOLE_PORT change: key={key}, op={op}")
        self._sync()

    def _get_all_link_ids(self) -> Set[str]:
        """Get all link IDs from CONFIG_DB"""
        link_ids = set()
        try:
            table_data = self.config_db.get_table(CONSOLE_PORT_TABLE)
            for key in table_data.keys():
                key_str = str(key) if not isinstance(key, str) else key
                link_ids.add(key_str)
        except Exception as e:
            log.error(f"PTYHub: Failed to get link IDs: {e}")
        return link_ids

    def _sync(self) -> None:
        """Sync bridges with CONFIG_DB"""
        config_ids = self._get_all_link_ids()
        current_ids = set(self.bridges.keys())

        # Remove bridges not in config
        for link_id in current_ids - config_ids:
            log.info(f"PTYHub: Removing bridge for link {link_id}")
            self.bridges[link_id].stop()
            del self.bridges[link_id]

        # Add new bridges
        for link_id in config_ids - current_ids:
            log.info(f"PTYHub: Creating bridge for link {link_id}")
            bridge = PTYBridge(link_id, self.udev_prefix)
            if bridge.start():
                self.bridges[link_id] = bridge
            else:
                # Failed to create this bridge, but don't affect others
                log.error(f"PTYHub: Failed to create bridge for link {link_id}, skipping")

        log.info(f"PTYHub: Sync complete, {len(self.bridges)} bridges active")


# ============================================================
# Serial Proxy (State Machine with Auto-Recovery)
# ============================================================

class SerialProxy:
    """
    Serial Proxy: bridges serial port and PTM with heartbeat filtering

    State machine with auto-recovery:
    WAIT_UDEV_PREFIX -> WAIT_CONFIG -> WAIT_DEVICE -> WAIT_PTM -> RUNNING
                                                                    |
                                                         (error) ---+-> back to WAIT_DEVICE
    """

    def __init__(self, link_id: str):
        self.link_id = link_id
        self.running = False

        # Configuration (obtained during wait phases)
        self.udev_prefix: str = ""
        self.baud: int = DEFAULT_BAUD
        self.device_path: str = ""
        self.ptm_path: str = ""

        # Resources
        self.state_db: Optional[DBConnector] = None
        self.state_table: Optional[Table] = None
        self.ser_fd: int = -1
        self.ptm_fd: int = -1
        self.filter: Optional[FrameFilter] = None

        # State tracking
        self._current_oper_state: Optional[str] = None
        self._last_heartbeat_time: float = 0.0
        self._last_data_activity: float = 0.0
        self._last_serial_data_time: float = 0.0

        # Thread control
        self._thread: Optional[threading.Thread] = None
        self._wake_r: int = -1
        self._wake_w: int = -1

    def start(self) -> bool:
        """Start proxy in a background thread"""
        self.running = True
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()
        log.info(f"[SerialProxy:{self.link_id}] Thread started")
        return True

    def stop(self) -> None:
        """Stop proxy"""
        self.running = False

        # Wake up any blocking operation
        if self._wake_w >= 0:
            try:
                os.write(self._wake_w, b'x')
            except OSError:
                pass

        # Wait for thread
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=5.0)

        log.info(f"[SerialProxy:{self.link_id}] Stopped")

    def _run(self) -> None:
        """Main run method with state machine"""
        while self.running:
            try:
                # Phase 1: Wait for udev prefix
                if not self._wait_for_udev_prefix():
                    break

                # Phase 2: Wait for CONFIG_DB configuration
                if not self._wait_for_config():
                    break

                # Phase 3: Wait for device
                if not self._wait_for_device():
                    break

                # Phase 4: Wait for PTM
                if not self._wait_for_ptm():
                    break

                # Phase 5: Initialize and run
                if self._initialize():
                    self._run_loop()

                # Cleanup after run_loop exits (error or stop)
                self._cleanup_resources()

                # If still running, it means an error occurred, retry from Phase 3
                if self.running:
                    log.info(f"[SerialProxy:{self.link_id}] Will retry from device check...")
                    time.sleep(RETRY_INTERVAL)

            except Exception as e:
                log.error(f"[SerialProxy:{self.link_id}] Run error: {e}")
                self._cleanup_resources()
                if self.running:
                    time.sleep(RETRY_INTERVAL)

    def _wait_for_udev_prefix(self) -> bool:
        """Phase 1: Wait for udev prefix"""
        log.info(f"[SerialProxy:{self.link_id}] Phase 1: Waiting for udev prefix...")

        while self.running:
            prefix = get_udev_prefix()
            if prefix:
                self.udev_prefix = prefix
                self.device_path = f"/dev/{prefix}{self.link_id}"
                self.ptm_path = f"/dev/{prefix}{self.link_id}{PTY_SYMLINK_SUFFIX_PTM}"
                log.info(f"[SerialProxy:{self.link_id}] Udev prefix: {prefix}")
                return True

            time.sleep(RETRY_INTERVAL)

        return False

    def _wait_for_config(self) -> bool:
        """Phase 2: Wait for CONFIG_DB configuration"""
        log.info(f"[SerialProxy:{self.link_id}] Phase 2: Waiting for CONFIG_DB config...")

        config_db = ConfigDBConnector()
        config_db.connect(wait_for_init=True, retry_on=True)

        while self.running:
            entry = config_db.get_entry(CONSOLE_PORT_TABLE, self.link_id)
            if entry:
                self.baud = int(entry.get('baud_rate', DEFAULT_BAUD))
                log.info(f"[SerialProxy:{self.link_id}] Config loaded: baud={self.baud}")
                return True

            log.debug(f"[SerialProxy:{self.link_id}] Config not found, retrying...")
            time.sleep(RETRY_INTERVAL)

        return False

    def _wait_for_device(self) -> bool:
        """Phase 3: Wait for device to exist"""
        log.info(f"[SerialProxy:{self.link_id}] Phase 3: Waiting for device {self.device_path}...")

        while self.running:
            if os.path.exists(self.device_path):
                log.info(f"[SerialProxy:{self.link_id}] Device ready: {self.device_path}")
                return True

            log.debug(f"[SerialProxy:{self.link_id}] Device not found, retrying...")
            time.sleep(RETRY_INTERVAL)

        return False

    def _wait_for_ptm(self) -> bool:
        """Phase 4: Wait for PTM symlink to exist"""
        log.info(f"[SerialProxy:{self.link_id}] Phase 4: Waiting for PTM {self.ptm_path}...")

        while self.running:
            if os.path.exists(self.ptm_path):
                log.info(f"[SerialProxy:{self.link_id}] PTM ready: {self.ptm_path}")
                return True

            log.debug(f"[SerialProxy:{self.link_id}] PTM not found, retrying...")
            time.sleep(RETRY_INTERVAL)

        return False

    def _initialize(self) -> bool:
        """Phase 5 init: open serial port, PTM, connect to Redis"""
        try:
            # Connect to STATE_DB
            self.state_db = DBConnector("STATE_DB", 0)
            self.state_table = Table(self.state_db, CONSOLE_PORT_TABLE)

            # Create wake-up pipe
            self._wake_r, self._wake_w = os.pipe()
            set_nonblocking(self._wake_r)

            # Open serial port
            self.ser_fd = os.open(self.device_path, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)
            configure_serial(self.ser_fd, self.baud)

            # Open PTM
            self.ptm_fd = os.open(self.ptm_path, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)

            # Create frame filter
            self.filter = FrameFilter(
                on_frame=self._on_frame_received,
                on_user_data=self._on_user_data_received,
            )

            self._last_heartbeat_time = time.monotonic()
            self._last_data_activity = time.monotonic()
            self._current_oper_state = None

            log.info(f"[SerialProxy:{self.link_id}] Initialized: {self.device_path} <-> {self.ptm_path}")
            return True

        except Exception as e:
            log.error(f"[SerialProxy:{self.link_id}] Initialize failed: {e}")
            return False

    def _run_loop(self) -> None:
        """Main loop with select"""
        filter_timeout = calculate_filter_timeout(self.baud)

        while self.running:
            try:
                # Calculate select timeout
                now = time.monotonic()
                time_since_heartbeat = now - self._last_heartbeat_time
                select_timeout = max(0.1, HEARTBEAT_TIMEOUT - time_since_heartbeat)

                # Consider filter timeout if pending data
                if self.filter and self.filter.has_pending_data():
                    time_since_serial = now - self._last_serial_data_time
                    remaining = filter_timeout - time_since_serial
                    if remaining > 0:
                        select_timeout = min(select_timeout, remaining)
                    else:
                        select_timeout = 0

                # Select on serial, PTM, and wake-up pipe
                readable, _, _ = select.select(
                    [self.ser_fd, self.ptm_fd, self._wake_r],
                    [], [],
                    select_timeout
                )

                if not self.running:
                    break

                serial_data_received = False
                for fd in readable:
                    if fd == self.ser_fd:
                        self._on_serial_read()
                        serial_data_received = True
                    elif fd == self.ptm_fd:
                        self._on_ptm_read()
                    elif fd == self._wake_r:
                        try:
                            os.read(self._wake_r, 1024)
                        except OSError:
                            pass

                # Check heartbeat timeout
                self._check_heartbeat_timeout()

                # Check filter timeout
                if self.filter and self.filter.has_pending_data() and not serial_data_received:
                    now = time.monotonic()
                    if now - self._last_serial_data_time >= filter_timeout:
                        self.filter.on_timeout()

            except OSError as e:
                # Device disconnected, exit loop to trigger recovery
                log.warning(f"[SerialProxy:{self.link_id}] Device error: {e}")
                break
            except Exception as e:
                if self.running:
                    log.error(f"[SerialProxy:{self.link_id}] Loop error: {e}")
                    time.sleep(0.1)

    def _on_serial_read(self) -> None:
        """Handle serial port read"""
        if not self.running or not self.filter:
            return
        try:
            data = os.read(self.ser_fd, 4096)
            if data:
                now = time.monotonic()
                self._last_data_activity = now
                self._last_serial_data_time = now
                self.filter.process(data)
        except (BlockingIOError, OSError) as e:
            if isinstance(e, OSError) and e.errno not in (11, 35):  # EAGAIN
                raise

    def _on_ptm_read(self) -> None:
        """Handle PTM read"""
        if not self.running:
            return
        try:
            data = os.read(self.ptm_fd, 4096)
            if data:
                os.write(self.ser_fd, data)
        except (BlockingIOError, OSError) as e:
            if isinstance(e, OSError) and e.errno not in (11, 35):  # EAGAIN
                raise

    def _on_frame_received(self, frame: Frame) -> None:
        """Handle received frame"""
        if frame.is_heartbeat():
            self._last_heartbeat_time = time.monotonic()
            self._update_state("Up")
            log.debug(f"[SerialProxy:{self.link_id}] Heartbeat received (seq={frame.seq})")
        else:
            log.warning(f"[SerialProxy:{self.link_id}] Unknown frame type: {frame.frame_type}")

    def _on_user_data_received(self, data: bytes) -> None:
        """Handle user data (forward to PTM)"""
        if self.ptm_fd >= 0:
            try:
                os.write(self.ptm_fd, data)
            except OSError:
                pass

    def _check_heartbeat_timeout(self) -> None:
        """Check heartbeat timeout"""
        now = time.monotonic()
        time_since_heartbeat = now - self._last_heartbeat_time

        if time_since_heartbeat >= HEARTBEAT_TIMEOUT:
            time_since_data = now - self._last_data_activity
            if time_since_data < HEARTBEAT_TIMEOUT:
                log.debug(f"[SerialProxy:{self.link_id}] Heartbeat timeout but data activity detected")
                self._last_heartbeat_time = now
                return

            self._update_state("Unknown")
            self._last_heartbeat_time = now

    def _update_state(self, oper_state: str) -> None:
        """Update STATE_DB (only on change)"""
        if oper_state == self._current_oper_state:
            return

        self._current_oper_state = oper_state
        timestamp = str(int(time.time()))

        try:
            self.state_table.set(
                self.link_id,
                [("oper_state", oper_state), ("last_state_change", timestamp)]
            )
            log.info(f"[SerialProxy:{self.link_id}] State: {oper_state}")
        except Exception as e:
            log.error(f"[SerialProxy:{self.link_id}] Failed to update state: {e}")

    def _cleanup_state(self) -> None:
        """Cleanup STATE_DB entries"""
        try:
            if self.state_table:
                self.state_table.hdel(self.link_id, "oper_state")
                self.state_table.hdel(self.link_id, "last_state_change")
                log.debug(f"[SerialProxy:{self.link_id}] STATE_DB cleaned up")
        except Exception as e:
            log.error(f"[SerialProxy:{self.link_id}] Failed to cleanup STATE_DB: {e}")

    def _cleanup_resources(self) -> None:
        """Cleanup all resources (but keep running state)"""
        # Cleanup STATE_DB
        self._cleanup_state()

        # Flush remaining data
        if self.filter and self.ptm_fd >= 0:
            remaining = self.filter.flush()
            if remaining:
                try:
                    os.write(self.ptm_fd, remaining)
                except OSError:
                    pass

        # Close file descriptors
        for fd in (self._wake_r, self._wake_w, self.ser_fd, self.ptm_fd):
            if fd >= 0:
                try:
                    os.close(fd)
                except OSError:
                    pass

        self._wake_r = self._wake_w = -1
        self.ser_fd = self.ptm_fd = -1
        self.filter = None
        self.state_db = None
        self.state_table = None
        self._current_oper_state = None


# ============================================================
# DCE Service (Simplified)
# ============================================================

class DCEService:
    """
    DCE Service: manages SerialProxy instances

    Only responsible for:
    - Listening to CONFIG_DB changes
    - Checking feature enabled status
    - Starting/stopping SerialProxy threads
    """

    def __init__(self):
        self.config_db: Optional[ConfigDBConnector] = None
        self.proxies: Dict[str, SerialProxy] = {}
        self.running: bool = False

    def start(self) -> bool:
        """Start DCE service"""
        try:
            self.config_db = ConfigDBConnector()
            self.config_db.connect(wait_for_init=True, retry_on=True)
            log.info("DCE: ConfigDB connected")

            self.running = True
            return True

        except Exception as e:
            log.error(f"DCE: Failed to start: {e}")
            return False

    def register_callbacks(self) -> None:
        """Register CONFIG_DB change callbacks"""

        def make_callback(func):
            def callback(table, key, data):
                if data is None:
                    op = "DEL"
                    data = {}
                else:
                    op = "SET"
                return func(key, op, data)
            return callback

        self.config_db.subscribe(CONSOLE_PORT_TABLE,
                                 make_callback(self.console_port_handler))
        self.config_db.subscribe(CONSOLE_SWITCH_TABLE,
                                 make_callback(self.console_switch_handler))

        log.info("DCE: Callbacks registered")

    def run(self) -> None:
        """Main loop: listen for CONFIG_DB changes"""
        try:
            self.config_db.listen(init_data_handler=self._load_initial_config)
        except KeyboardInterrupt:
            log.info("DCE: Received keyboard interrupt")
        except Exception as e:
            if self.running:
                log.error(f"DCE: Listen error: {e}")

    def stop(self) -> None:
        """Stop DCE service"""
        self.running = False

        for proxy in self.proxies.values():
            proxy.stop()
        self.proxies.clear()

        log.info("DCE: Stopped")

    def _load_initial_config(self, init_data: dict) -> None:
        """Load initial configuration"""
        log.info(f"DCE: Loading initial config: {list(init_data.keys())}")
        self._sync()

    def console_port_handler(self, key: str, op: str, data: dict) -> None:
        """CONSOLE_PORT table change handler"""
        log.info(f"DCE: CONSOLE_PORT change: key={key}, op={op}")
        self._sync()

    def console_switch_handler(self, key: str, op: str, data: dict) -> None:
        """CONSOLE_SWITCH table change handler"""
        log.info(f"DCE: CONSOLE_SWITCH change: key={key}, op={op}")
        self._sync()

    def _check_feature_enabled(self) -> bool:
        """Check if console switch feature is enabled"""
        try:
            entry = self.config_db.get_entry(CONSOLE_SWITCH_TABLE, "console_mgmt")
            if entry:
                if entry.get("enabled", "") == "yes":
                    return True
            log.warning("DCE: Console switch feature is disabled")
            return False
        except Exception as e:
            log.error(f"DCE: Failed to check feature status: {e}")
            return False

    def _get_all_link_ids(self) -> Set[str]:
        """Get all link IDs from CONFIG_DB"""
        link_ids = set()
        try:
            table_data = self.config_db.get_table(CONSOLE_PORT_TABLE)
            for key in table_data.keys():
                key_str = str(key) if not isinstance(key, str) else key
                link_ids.add(key_str)
        except Exception as e:
            log.error(f"DCE: Failed to get link IDs: {e}")
        return link_ids

    def _sync(self) -> None:
        """Sync proxies with CONFIG_DB"""
        # Check feature enabled
        if not self._check_feature_enabled():
            if self.proxies:
                log.info("DCE: Feature disabled, stopping all proxies")
                for proxy in self.proxies.values():
                    proxy.stop()
                self.proxies.clear()
            return

        config_ids = self._get_all_link_ids()
        current_ids = set(self.proxies.keys())

        # Remove proxies not in config
        for link_id in current_ids - config_ids:
            log.info(f"DCE: Stopping proxy for link {link_id}")
            self.proxies[link_id].stop()
            del self.proxies[link_id]

        # Add new proxies (only pass link_id, proxy handles the rest)
        for link_id in config_ids - current_ids:
            log.info(f"DCE: Starting proxy for link {link_id}")
            proxy = SerialProxy(link_id)
            proxy.start()
            self.proxies[link_id] = proxy

        log.info(f"DCE: Sync complete, {len(self.proxies)} proxies active")


# ============================================================
# DTE Service
# ============================================================

class DTEService:
    """
    DTE side service: sends heartbeat frames
    """

    def __init__(self, tty_name: str, baud: int):
        self.tty_name = tty_name
        self.baud = baud
        self.device_path = f"/dev/{tty_name}"

        self.config_db: Optional[ConfigDBConnector] = None

        self.running: bool = False
        self.enabled: bool = False
        self.seq: int = 0

        self._heartbeat_thread: Optional[threading.Thread] = None
        self._heartbeat_stop: threading.Event = threading.Event()

    def start(self) -> bool:
        """Start service"""
        try:
            self.config_db = ConfigDBConnector()
            self.config_db.connect(wait_for_init=True, retry_on=True)
            log.info("DTE: ConfigDB connected")

            self.running = True
            log.info(f"DTE: Service initialized: {self.device_path}")
            return True

        except Exception as e:
            log.error(f"DTE: Failed to start: {e}")
            return False

    def register_callbacks(self) -> None:
        """Register CONFIG_DB change callbacks"""

        def make_callback(func):
            def callback(table, key, data):
                if data is None:
                    op = "DEL"
                    data = {}
                else:
                    op = "SET"
                return func(key, op, data)
            return callback

        self.config_db.subscribe(CONSOLE_SWITCH_TABLE,
                                 make_callback(self.console_switch_handler))

        log.info("DTE: Callbacks registered")

    def run(self) -> None:
        """Main loop"""
        try:
            self.config_db.listen(init_data_handler=self._load_initial_config)
        except KeyboardInterrupt:
            log.info("DTE: Received keyboard interrupt")
        except Exception as e:
            if self.running:
                log.error(f"DTE: Listen error: {e}")

    def stop(self) -> None:
        """Stop service"""
        self.running = False
        self._stop_heartbeat()
        log.info("DTE: Stopped")

    def _load_initial_config(self, init_data: dict) -> None:
        """Load initial configuration"""
        log.info(f"DTE: Loading initial config: {list(init_data.keys())}")

        self.enabled = self._check_enabled()
        log.info(f"DTE: Initial enabled state: {self.enabled}")

        if self.enabled:
            self._start_heartbeat()

    def console_switch_handler(self, key: str, op: str, data: dict) -> None:
        """CONSOLE_SWITCH table change handler"""
        log.info(f"DTE: CONSOLE_SWITCH change: key={key}, op={op}")

        new_enabled = self._check_enabled()
        if new_enabled != self.enabled:
            log.info(f"DTE: Enabled state changed: {self.enabled} -> {new_enabled}")
            self.enabled = new_enabled

            if self.enabled:
                self._start_heartbeat()
            else:
                self._stop_heartbeat()

    def _check_enabled(self) -> bool:
        """Check the enabled field of controlled_device"""
        try:
            entry = self.config_db.get_entry(CONSOLE_SWITCH_TABLE, "controlled_device")
            if entry:
                return entry.get("enabled", "") == "yes"
            return False
        except Exception as e:
            log.warning(f"DTE: Failed to check enabled status: {e}")
            return False

    def _start_heartbeat(self) -> None:
        """Start heartbeat thread"""
        if self._heartbeat_thread and self._heartbeat_thread.is_alive():
            return

        self._heartbeat_stop.clear()
        self._heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self._heartbeat_thread.start()
        log.info("DTE: Heartbeat thread started")

    def _stop_heartbeat(self) -> None:
        """Stop heartbeat thread"""
        self._heartbeat_stop.set()
        if self._heartbeat_thread and self._heartbeat_thread.is_alive():
            self._heartbeat_thread.join(timeout=2.0)
        self._heartbeat_thread = None
        log.info("DTE: Heartbeat thread stopped")

    def _heartbeat_loop(self) -> None:
        """Heartbeat send loop"""
        while not self._heartbeat_stop.is_set():
            self._send_heartbeat()
            self._heartbeat_stop.wait(HEARTBEAT_INTERVAL)

    def _send_heartbeat(self) -> None:
        """Send heartbeat frame"""
        frame = Frame.create_heartbeat(self.seq)
        frame_bytes = frame.build()

        try:
            fd = os.open(self.device_path, os.O_WRONLY | os.O_NOCTTY | os.O_NONBLOCK)
            try:
                os.write(fd, frame_bytes)
                log.debug(f"DTE: Sent heartbeat (seq={self.seq})")
                log_binary_data(frame_bytes, "DTE→Serial")
                self.seq = (self.seq + 1) % 256
            finally:
                os.close(fd)
        except Exception as e:
            log.error(f"DTE: Failed to send heartbeat: {e}")


# ============================================================
# Main Program Entry
# ============================================================

def signal_handler(signum, frame):
    """Global signal handler"""
    log.info(f"Received signal {signum}")
    raise SystemExit(0)


def run_ptyhub() -> int:
    """PTY Hub service entry point"""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)

    service = PTYHub()

    if not service.start():
        return EXIT_SERVICE_START_FAILED

    try:
        service.register_callbacks()
        service.run()
    except SystemExit:
        pass
    finally:
        service.stop()

    return EXIT_SUCCESS


def run_dce() -> int:
    """DCE service entry point"""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)

    service = DCEService()

    if not service.start():
        return EXIT_SERVICE_START_FAILED

    try:
        service.register_callbacks()
        service.run()
    except SystemExit:
        pass
    finally:
        service.stop()

    return EXIT_SUCCESS


def run_dte() -> int:
    """DTE service entry point"""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGHUP, signal_handler)

    parser = argparse.ArgumentParser(description='Console Monitor DTE Service')
    parser.add_argument('tty_name', nargs='?', default=None, help='TTY device name')
    parser.add_argument('baud', nargs='?', type=int, default=None, help='Baud rate')
    args = parser.parse_args()

    if args.tty_name:
        tty_name = args.tty_name
        baud = args.baud if args.baud else DEFAULT_BAUD
        log.info(f"DTE: Using command line args: tty={tty_name}, baud={baud}")
    else:
        try:
            tty_name, baud = parse_proc_cmdline()
        except ValueError as e:
            log.error(f"DTE: Failed to get serial config: {e}")
            return EXIT_SERIAL_CONFIG_ERROR

    service = DTEService(tty_name, baud)

    if not service.start():
        return EXIT_SERVICE_START_FAILED

    try:
        service.register_callbacks()
        service.run()
    except SystemExit:
        pass
    finally:
        service.stop()

    return EXIT_SUCCESS


def main():
    """
    Unified entry point

    Usage:
        console-monitor ptyhub   # Run PTY Hub service
        console-monitor dce      # Run DCE service
        console-monitor dte      # Run DTE service
    """
    if len(sys.argv) < 2:
        print("Usage: console-monitor <ptyhub|dce|dte> [args...]")
        print("  ptyhub: Run PTY Hub service (creates PTY bridges)")
        print("  dce: Run DCE (Console Server) service")
        print("  dte: Run DTE (SONiC Switch) service")
        sys.exit(EXIT_INVALID_MODE)

    mode = sys.argv[1].lower()
    sys.argv = sys.argv[1:]  # Remove mode argument for argparse

    if mode == "ptyhub":
        sys.exit(run_ptyhub())
    elif mode == "dce":
        sys.exit(run_dce())
    elif mode == "dte":
        sys.exit(run_dte())
    else:
        print(f"Unknown mode: {mode}")
        print("Use 'ptyhub', 'dce' or 'dte'")
        sys.exit(EXIT_INVALID_MODE)


if __name__ == "__main__":
    main()
