## Rust 重写内存估算

### 当前 Python 实现内存分析

```
Python 进程内存构成（约 16.6M/进程）：
├── Python 解释器      ~8-10M  （固定开销）
├── 标准库 + 第三方库   ~4-5M   （asyncio, redis, etc）
└── 实际运行时数据      ~2-3M   （buffer, 状态）
```

### Rust 预估对比

| 架构方案 | 进程数 | 单进程内存 | 总内存 | 对比 Python |
|---------|--------|-----------|--------|-------------|
| **多进程** (保持现有架构) | 49 | 2-4M | **100-200M** | 节省 75-88% |
| **单进程多线程** (推荐) | 1 | 20-40M | **20-40M** | 节省 95-97% |

### 单进程多线程详细估算

```
Rust 单进程内存构成：
├── 二进制 + 运行时        ~3-5M
├── Tokio 异步运行时       ~2-3M
├── Redis 连接池           ~1-2M
├── 48 个端口的数据结构
│   ├── 每端口 buffer      ~64KB × 48 = ~3M
│   ├── 每端口状态         ~1KB × 48  = ~48KB
│   └── PTY/串口句柄       ~2KB × 48  = ~96KB
└── 其他开销               ~5-10M
────────────────────────────────
总计                        ~20-40M
```

### 总结

| 指标 | Python (当前) | Rust (多进程) | Rust (单进程) |
|------|--------------|---------------|---------------|
| 总内存 | **810M** | **~150M** | **~30M** |
| 进程数 | 49 | 49 | 1 |
| 节省比例 | - | ~80% | **~96%** |

**推荐方案**：Rust + 单进程多线程（tokio）

- 内存从 **810M → 30M**（节省约 **96%**）
- 额外好处：启动更快、无 GIL 限制、更低的上下文切换开销

---

### 实现复杂度

如果考虑重写，核心模块大致工作量：

| 模块 | 复杂度 | 说明 |
|------|--------|------|
| frame.rs | 低 | 帧编解码、CRC |
| serial_proxy.rs | 中 | PTY + 串口桥接 |
| db_util.rs | 低 | Redis 交互 |
| dce.rs | 中 | 主控逻辑、线程管理 |

总体约 **1-2 周**工作量（熟悉 Rust 的情况下）。

### Rust 移植的主要障碍

**SONiC 专属依赖问题**：

| Python 依赖 | 用途 | Rust 替代方案 | 难度 |
|-------------|------|---------------|------|
| `swsscommon.swsscommon` | Redis 通信 (CONFIG_DB/STATE_DB) | ❌ **无直接替代** | **极高** |
| `sonic_py_common.device_info` | 获取平台路径 | ⚠️ 需读取文件系统 | 中 |
| `ConfigDBConnector.subscribe/listen` | 配置变更监听 | ❌ **需重新实现** | **极高** |

- `swsscommon` 是 SONiC 的 C++ 库，只有 Python binding，**没有官方 Rust binding**
- 需要逆向 Redis 协议格式或为 swsscommon 编写 Rust binding

---

## C++ 重写内存估算

### C++ 的关键优势：SONiC 原生支持

**swsscommon 本身就是 C++ 库**，Python binding 只是它的封装。C++ 可以直接使用原生 API：

```cpp
#include <swss/dbconnector.h>
#include <swss/table.h>
#include <swss/subscriberstatetable.h>

using namespace swss;

// 连接数据库
DBConnector config_db("CONFIG_DB", 0);
Table console_table(&config_db, "CONSOLE_PORT");

// 监听变更 (SONiC 标准模式)
SubscriberStateTable sub_table(&config_db, "CONSOLE_PORT");
Select selector;
selector.addSelectable(&sub_table);
```

### C++ vs Python 单进程内存对比

| 组件 | Python 进程 | C++ 进程 |
|------|------------|----------|
| 运行时/解释器 | ~8-10M | 0 (无解释器) |
| 标准库加载 | ~4-5M | ~1-2M (动态链接) |
| swsscommon | ~2-3M | ~1-2M |
| 运行时数据 | ~2-3M | ~0.5-1M |
| **单进程总计** | **~16-20M** | **~3-5M** |

### C++ 多进程方案

```
┌─────────────────────────────────────────────────────┐
│  console-monitor-dce (C++ 主进程)      ~4-5M        │
│  - swsscommon 连接                                  │
│  - 监听 CONFIG_DB                                   │
│  - 管理 systemctl 调用                              │
└─────────────────────────────────────────────────────┘
                          │
     ┌────────────────────┼────────────────────┐
     ↓                    ↓                    ↓
┌─────────┐         ┌─────────┐         ┌─────────┐
│proxy@1  │         │proxy@2  │   ...   │proxy@48 │
│ ~3-4M   │         │ ~3-4M   │         │ ~3-4M   │
└─────────┘         └─────────┘         └─────────┘
```

### C++ 单进程内存详细构成

```
C++ 进程内存构成 (约 3-5M/进程):
├── 程序代码段 (.text)           ~200-500KB
├── 动态库
│   ├── libc.so                  ~共享，不重复计算
│   ├── libstdc++.so             ~共享
│   ├── libswsscommon.so         ~1-2M
│   └── libhiredis.so            ~200KB
├── 堆内存
│   ├── Redis 连接               ~100-200KB
│   ├── 串口 buffer              ~64KB
│   └── 其他数据结构              ~100KB
├── 栈                           ~8KB (默认)
└── 其他                         ~500KB
```

### C++ 预估对比

| 架构方案 | 进程数 | 单进程内存 | 总内存 | 对比 Python |
|---------|--------|-----------|--------|-------------|
| **多进程** (保持现有架构) | 49 | 3-5M | **150-250M** | 节省 70-80% |
| **单进程多线程** (推荐) | 1 | 20-40M | **20-40M** | 节省 95-97% |

### C++ 移植工作量评估

| 模块 | 工时 | 难度 |
|------|------|------|
| Frame 协议 (CRC, 编解码) | 0.5 天 | 简单 |
| FrameFilter 状态机 | 0.5 天 | 简单 |
| 串口/PTY 代理 | 1-2 天 | 中等 |
| swsscommon 集成 | 1 天 | **简单** (有现成 API) |
| DCE 服务逻辑 | 1-2 天 | 中等 |
| DTE 服务逻辑 | 1 天 | 简单 |
| 多线程/Select 架构 | 1-2 天 | 中等 |
| 测试 + 调试 | 2-3 天 | |
| **总计** | **~2 周** | |

### C++ 的额外优势

- SONiC 有大量 C++ daemon 参考实现 (orchagent, portsyncd, neighsyncd 等)
- 可使用 SONiC 标准的 `swss::Select` 框架和 `swss/logger.h` 日志
- 社区接受度最高

---

## 全方案对比总结

| 方案 | 总内存 | 节省比例 | 工作量 | SONiC 兼容性 | 推荐度 |
|------|--------|----------|--------|--------------|--------|
| Python 多进程 (当前) | **810M** | 基准 | - | ✅ 好 | - |
| Python 单进程多线程 | **60-80M** | ~90% | 1 周 | ✅ 好 | ⭐⭐⭐⭐⭐ |
| C++ 多进程 | **150-250M** | ~70-80% | 2 周 | ✅ 最佳 | ⭐⭐ |
| C++ 单进程多线程 | **20-40M** | ~95-97% | 2 周 | ✅ 最佳 | ⭐⭐⭐⭐ |
| Rust 多进程 | **100-200M** | ~75-88% | 3-4 周 | ⚠️ 差 | ⭐ |
| Rust 单进程多线程 | **20-40M** | ~95-97% | 3-4 周 | ⚠️ 差 | ⭐⭐ |

### 推荐路线

```
当前 Python 多进程 (810M)
       ↓ (1周)
Python 多线程 (60-80M)  ← 优先做这个，验证效果
       ↓ (如果还需优化，2周)
C++ 单进程多线程 (20-40M)  ← 长期最优方案
```

**结论**：
- **短期**：Python 多线程重构，性价比最高
- **长期**：C++ 单进程是 SONiC 生态的"一等公民"，移植后更容易被社区接受